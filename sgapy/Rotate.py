# Autogenerated with SMOP 
from smop.core import *
# Rotate.m

    
@function
def Rotate(raz=None,rdip=None,rot=None,trd=None,plg=None,ans0=None,*args,**kwargs):
    varargin = Rotate.varargin
    nargin = Rotate.nargin

    #Rotate rotates a line by performing a coordinate transformation on
#vectors. The algorithm was originally written by Randall A. Marrett
    
    #   USE: [rtrd,rplg] = Rotate(raz,rdip,rot,trd,plg,ans0)
    
    #   raz = trend of rotation axis
#   rdip = plunge of rotation axis
#   rot = magnitude of rotation
#   trd = trend of the vector to be rotated
#   plg = plunge of the vector to be rotated
#   ans0 = A character indicating whether the line to be rotated is an axis
#   (ans0 = 'a') or a vector (ans0 = 'v')
    
    #   NOTE: All angles are in radians
    
    #   Rotate uses functions SphToCart and CartToSph
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Allocate some arrays
    a=zeros(3,3)
# Rotate.m:24
    
    pole=zeros(1,3)
# Rotate.m:25
    
    plotr=zeros(1,3)
# Rotate.m:26
    
    temp=zeros(1,3)
# Rotate.m:27
    
    #Convert rotation axis to direction cosines. Note that the convention here
#is X1 = North, X2 = East, X3 = Down
    pole[1],pole[2],pole[3]=SphToCart(raz,rdip,0,nargout=3)
# Rotate.m:31
    # Calculate the transformation matrix
    x=1.0 - cos(rot)
# Rotate.m:34
    sinRot=sin(rot)
# Rotate.m:35
    
    cosRot=cos(rot)
# Rotate.m:36
    a[1,1]=cosRot + dot(dot(pole[1],pole[1]),x)
# Rotate.m:37
    a[1,2]=dot(- pole[3],sinRot) + dot(dot(pole[1],pole[2]),x)
# Rotate.m:38
    a[1,3]=dot(pole[2],sinRot) + dot(dot(pole[1],pole[3]),x)
# Rotate.m:39
    a[2,1]=dot(pole[3],sinRot) + dot(dot(pole[2],pole[1]),x)
# Rotate.m:40
    a[2,2]=cosRot + dot(dot(pole[2],pole[2]),x)
# Rotate.m:41
    a[2,3]=dot(- pole[1],sinRot) + dot(dot(pole[2],pole[3]),x)
# Rotate.m:42
    a[3,1]=dot(- pole[2],sinRot) + dot(dot(pole[3],pole[1]),x)
# Rotate.m:43
    a[3,2]=dot(pole[1],sinRot) + dot(dot(pole[3],pole[2]),x)
# Rotate.m:44
    a[3,3]=cosRot + dot(dot(pole[3],pole[3]),x)
# Rotate.m:45
    #Convert trend and plunge of vector to be rotated into direction cosines
    temp[1],temp[2],temp[3]=SphToCart(trd,plg,0,nargout=3)
# Rotate.m:48
    #The following nested loops perform the coordinate transformation
    for i in arange(1,3).reshape(-1):
        plotr[i]=0.0
# Rotate.m:52
        for j in arange(1,3).reshape(-1):
            plotr[i]=dot(a[i,j],temp[j]) + plotr[i]
# Rotate.m:54
    
    #Convert to lower hemisphere projection if data are axes (ans0 = 'a')
    if plotr[3] < 0.0 and ans0 == 'a':
        plotr[1]=- plotr[1]
# Rotate.m:60
        plotr[2]=- plotr[2]
# Rotate.m:61
        plotr[3]=- plotr[3]
# Rotate.m:62
    
    #Convert from direction cosines back to trend and plunge
    rtrd,rplg=CartToSph(plotr[1],plotr[2],plotr[3],nargout=2)
# Rotate.m:66
    return rtrd,rplg
    
if __name__ == '__main__':
    pass
    