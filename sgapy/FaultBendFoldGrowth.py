# Autogenerated with SMOP 
from smop.core import *
# FaultBendFoldGrowth.m

    
@function
def FaultBendFoldGrowth(yp=None,psect=None,pramp=None,pslip=None,G=None,*args,**kwargs):
    varargin = FaultBendFoldGrowth.varargin
    nargin = FaultBendFoldGrowth.nargin

    #FaultBendFoldGrowth plots the evolution of a simple step, Mode I fault 
#bend fold and adds growth strata for a given subsidence versus uplift rate
    
    #   USE: frames = FaultBendFoldGrowth(yp,psect,pramp,pslip,G)
    
    #   yp = Datums or vertical coordinates of undeformed, horizontal beds
#   psect = A 1 x 2 vector containing the extent of the section, and the 
#           number of points in each bed
#   pramp = A 1 x 3 vector containing the x coordinate of the lower bend in
#           the decollement, the ramp angle, and the height of the ramp
#   pslip = A 1 x 2 vector containing the total and incremental slip
#   G = Subsidence versus uplift rate
#   frames = An array structure containing the frames of the fold evolution
#            You can play the movie again just by typing movie(frames)
#   
#   NOTE: Input ramp angle should be in radians
    
    #   FaultBendFoldGrowth uses function SuppeEquation
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Top of layers
    top=yp[max(size(yp))]
# FaultBendFoldGrowth.m:26
    #Extent of section and number of points in each bed
    extent=psect[1]
# FaultBendFoldGrowth.m:29
    npoint=psect[2]
# FaultBendFoldGrowth.m:29
    #Make undeformed beds geometry: This is a grid of points along the beds
    xp=arange(0.0,extent,extent / npoint)
# FaultBendFoldGrowth.m:31
    XP,YP=meshgrid(xp,yp,nargout=2)
# FaultBendFoldGrowth.m:32
    #Fault geometry and slip
    xramp=pramp[1]
# FaultBendFoldGrowth.m:35
    ramp=pramp[2]
# FaultBendFoldGrowth.m:35
    height=pramp[3]
# FaultBendFoldGrowth.m:35
    slip=pslip[1]
# FaultBendFoldGrowth.m:36
    sinc=pslip[2]
# FaultBendFoldGrowth.m:36
    #Number of slip increments
    ninc=round(slip / sinc)
# FaultBendFoldGrowth.m:38
    # Make ten growth strata
    nincG=round(ninc / 10)
# FaultBendFoldGrowth.m:41
    # Initialize count of growth strata to 1
    countG=1
# FaultBendFoldGrowth.m:43
    #Ramp angle cannot be greater than 30 degrees, and if it is 30 degrees, 
#make it a little bit smaller to avoid convergence problems
    if ramp > dot(30,pi) / 180:
        error('ramp angle cannot be more than 30 degrees')
    else:
        if ramp == dot(30,pi) / 180:
            ramp=dot(29.9,pi) / 180
# FaultBendFoldGrowth.m:50
    
    #Minimize Eq. 11.8 to obtain gamma from the input ramp angle (theta)
    options=optimset('display','off')
# FaultBendFoldGrowth.m:54
    gama=fzero('SuppeEquation',1.5,options,ramp)
# FaultBendFoldGrowth.m:55
    #Compute slip ratio R (Eq. 11.8)
    R=sin(gama - ramp) / sin(gama)
# FaultBendFoldGrowth.m:57
    #Make fault geometry
    xf=matlabarray(cat(0,xramp,xramp + height / tan(ramp),dot(1.5,extent)))
# FaultBendFoldGrowth.m:60
    yf=matlabarray(cat(0,0,height,height))
# FaultBendFoldGrowth.m:61
    #From the origin of each bed compute the number of points that are in the
#hanging wall. These points are the ones that will move
    hwid=zeros(size(yp,2))
# FaultBendFoldGrowth.m:64
    for i in arange(1,size(yp,2)).reshape(-1):
        if yp[i] <= height:
            hwid[i]=0
# FaultBendFoldGrowth.m:67
            for j in arange(1,size(xp,2)).reshape(-1):
                if xp[j] <= xramp + yp[i] / tan(ramp):
                    hwid[i]=hwid[i] + 1
# FaultBendFoldGrowth.m:70
        else:
            hwid[i]=size(xp,2)
# FaultBendFoldGrowth.m:74
    
    #Deform beds: Apply velocity fields of Eq. 11.9
#Loop over slip increments
    for i in arange(1,ninc).reshape(-1):
        #Loop over number of beds
        for j in arange(1,size(XP,1)).reshape(-1):
            #number of hanging wall points in bed
        #If pregrowth bed
            if j <= size(yp,2):
                points=hwid[j]
# FaultBendFoldGrowth.m:86
            else:
                points=size(XP,2)
# FaultBendFoldGrowth.m:89
            #Loop over number of hanging wall points in each bed
            for k in arange(1,points).reshape(-1):
                #If point is in domain 1
                if XP[j,k] < xramp - dot(YP[j,k],tan(ramp / 2)):
                    XP[j,k]=XP[j,k] + sinc
# FaultBendFoldGrowth.m:95
                    YP[j,k]=YP[j,k]
# FaultBendFoldGrowth.m:96
                else:
                    #If point is in domain 2
                    if YP[j,k] < height:
                        XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# FaultBendFoldGrowth.m:101
                        YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# FaultBendFoldGrowth.m:102
                    else:
                        #If stage 1 of fault bend fold (Fig. 11.3a)
                        if dot(dot(i,sinc),sin(ramp)) < height:
                            #If point is in domain 2
                            if XP[j,k] < xramp + height / tan(ramp) + dot((YP[j,k] - height),tan(pi / 2 - gama)):
                                XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# FaultBendFoldGrowth.m:110
                                YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# FaultBendFoldGrowth.m:111
                            else:
                                XP[j,k]=XP[j,k] + dot(sinc,R)
# FaultBendFoldGrowth.m:114
                                YP[j,k]=YP[j,k]
# FaultBendFoldGrowth.m:115
                            #If stage 2 of fault bend fold (Fig. 11.3b)
                        else:
                            #If point is in domain 2
                            if XP[j,k] < xramp + height / tan(ramp) - dot((YP[j,k] - height),tan(ramp / 2)):
                                XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# FaultBendFoldGrowth.m:122
                                YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# FaultBendFoldGrowth.m:123
                            else:
                                XP[j,k]=XP[j,k] + dot(sinc,R)
# FaultBendFoldGrowth.m:126
                                YP[j,k]=YP[j,k]
# FaultBendFoldGrowth.m:127
        #Plot increment
    #Fault
        plot(xf,yf,'r-','LineWidth',2)
        hold('on')
        for j in arange(1,size(yp,2)).reshape(-1):
            #If below ramp
            if yp[j] <= height:
                plot(XP[j,1:1:hwid[j]],YP[j,1:1:hwid[j]],'k-')
                plot(XP[j,hwid[j] + 1:1:size(xp,2)],YP[j,hwid[j] + 1:1:size(xp,2)],'k-')
            else:
                plot(XP[j,:],YP[j,:],'k-')
        #Growth beds
        for j in arange(size(yp,2) + 1,size(XP,1)).reshape(-1):
            plot(XP[j,:],YP[j,:],'g-')
        #Plot settings
        text(dot(0.8,extent),dot(2.75,max(yp)),strcat('Slip = ',num2str(dot(i,sinc))))
        axis('equal')
        axis(cat(0,extent,0,dot(3.0,max(yp))))
        hold('off')
        frames[i]=getframe
# FaultBendFoldGrowth.m:160
        #are not calculated. Growth strata will not look right for subsidence
    #rate lower than uplift rate G < 1.0
        if (i == dot(countG,nincG)):
            #Update top
            totUpl=dot(dot(nincG,sinc),sin(ramp))
# FaultBendFoldGrowth.m:166
            if (totUpl <= height):
                top=top + dot(totUpl,G)
# FaultBendFoldGrowth.m:168
            #Make bed geometry
            xp=arange(dot(i,sinc),extent + dot(i,sinc),extent / npoint)
# FaultBendFoldGrowth.m:171
            GXP,GYP=meshgrid(xp,top,nargout=2)
# FaultBendFoldGrowth.m:172
            XP=matlabarray(cat([XP],[GXP]))
# FaultBendFoldGrowth.m:174
            YP=matlabarray(cat([YP],[GYP]))
# FaultBendFoldGrowth.m:175
            countG=countG + 1
# FaultBendFoldGrowth.m:177
    
    return frames
    
if __name__ == '__main__':
    pass
    