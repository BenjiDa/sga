# Autogenerated with SMOP 
from smop.core import *
# GridStrain.m

    
@function
def GridStrain(pos=None,disp=None,k=None,par=None,plotpar=None,*args,**kwargs):
    varargin = GridStrain.varargin
    nargin = GridStrain.nargin

    #GridStrain computes the infinitesimal strain of a network of stations with
#displacements in x (east) and y (north). Strain in z is assumed to be zero
    
    #   USE: [cent,eps,ome,pstrains,rotc] = GridStrain(pos,disp,k,par,plotpar)
    
    #   pos = nstations x 2 matrix with x (east) and y (north) positions 
#         of stations
#   disp = nstations x 2 matrix with x (east) and y (north) displacements 
#          of stations
#   k = Type of computation: Delaunay (k = 0), nearest neighbor (k = 1), or
#       distance weighted (k = 2).
#   par = Parameters for nearest neighbor or distance weighted computation. 
#         If Delaunay (k = 0), enter a scalar corresponding to the minimum
#         internal angle of a triangle valid for computation.
#         If nearest neighbor (k = 1), input a 1 x 3 vector with grid
#         spacing, number of nearest neighbors, and maximum distance
#         to neighbors.
#         If distance weighted (k = 2), input a 1 x 2 vector with grid 
#         spacing and distance weighting factor alpha
#   plotpar = Parameter to color the cells: Maximum elongation 
#             (plotpar = 0), minimum elongation (plotpar = 1),
#             rotation (plotpar = 2), or dilatation (plotpar = 3)
#   cent = ncells x 2 matrix with x and y positions of cells centroids
#   eps = 3 x 3 x ncells array  with strain tensors of the cells
#   ome = 3 x 3 x ncells array with rotation tensors of the cells
#   pstrains = 3 x 3 x ncells array with magnitude and orientation of
#             principal strains of the cells
#   rotc = ncells x 3 matrix with rotation components of cells
    
    #   NOTE: Input/Output angles should be in radians. Output azimuths are
#         given with respect to North
#         pos, disp, grid spacing, max. distance to neighbors, and alpha
#         should be in the same units of length
#   
#   GridStrain uses function InfStrain
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #If Delaunay
    if k == 0:
        #Indexes of triangle vertices: Use MATLAB built-in function delaunay
        inds=delaunay(pos[:,1],pos[:,2])
# GridStrain.m:45
        ncells=size(inds,1)
# GridStrain.m:47
        nstat=3
# GridStrain.m:49
        cent=zeros(ncells,2)
# GridStrain.m:51
        for i in arange(1,ncells).reshape(-1):
            #Triangle vertices
            v1x=pos[inds[i,1],1]
# GridStrain.m:54
            v2x=pos[inds[i,2],1]
# GridStrain.m:54
            v3x=pos[inds[i,3],1]
# GridStrain.m:54
            v1y=pos[inds[i,1],2]
# GridStrain.m:55
            v2y=pos[inds[i,2],2]
# GridStrain.m:55
            v3y=pos[inds[i,3],2]
# GridStrain.m:55
            cent[i,1]=(v1x + v2x + v3x) / 3.0
# GridStrain.m:57
            cent[i,2]=(v1y + v2y + v3y) / 3.0
# GridStrain.m:58
            s1=sqrt((v3x - v2x) ** 2 + (v3y - v2y) ** 2)
# GridStrain.m:60
            s2=sqrt((v1x - v3x) ** 2 + (v1y - v3y) ** 2)
# GridStrain.m:61
            s3=sqrt((v2x - v1x) ** 2 + (v2y - v1y) ** 2)
# GridStrain.m:62
            a1=acos(dot((v2x - v1x),(v3x - v1x)) / (dot(s3,s2)) + dot((v2y - v1y),(v3y - v1y)) / (dot(s3,s2)))
# GridStrain.m:63
            a2=acos(dot((v3x - v2x),(v1x - v2x)) / (dot(s1,s3)) + dot((v3y - v2y),(v1y - v2y)) / (dot(s1,s3)))
# GridStrain.m:64
            a3=acos(dot((v2x - v3x),(v1x - v3x)) / (dot(s1,s2)) + dot((v2y - v3y),(v1y - v3y)) / (dot(s1,s2)))
# GridStrain.m:65
            #invalidate triangle
            if a1 < par or a2 < par or a3 < par:
                inds[i,:]=zeros(1,3)
# GridStrain.m:69
        #Else if nearest neighbor or distance weighted
    else:
        #Construct grid
        xmin=min(pos[:,1])
# GridStrain.m:75
        xmax=max(pos[:,1])
# GridStrain.m:75
        ymin=min(pos[:,2])
# GridStrain.m:76
        ymax=max(pos[:,2])
# GridStrain.m:76
        cellsx=ceil((xmax - xmin) / par[1])
# GridStrain.m:77
        cellsy=ceil((ymax - ymin) / par[1])
# GridStrain.m:78
        xgrid=arange(xmin,(xmin + dot(cellsx,par[1])),par[1])
# GridStrain.m:79
        ygrid=arange(ymin,(ymin + dot(cellsy,par[1])),par[1])
# GridStrain.m:80
        XX,YY=meshgrid(xgrid,ygrid,nargout=2)
# GridStrain.m:81
        ncells=dot(cellsx,cellsy)
# GridStrain.m:83
        if k == 1:
            nstat=par[2]
# GridStrain.m:86
            #If distance weighted
        else:
            if k == 2:
                nstat=size(pos,1)
# GridStrain.m:89
        #centers of cells
        cent=zeros(ncells,2)
# GridStrain.m:92
        count=1
# GridStrain.m:93
        for i in arange(1,cellsy).reshape(-1):
            for j in arange(1,cellsx).reshape(-1):
                cent[count,1]=(XX[i,j] + XX[i,j + 1]) / 2.0
# GridStrain.m:96
                cent[count,2]=(YY[i,j] + YY[i + 1,j]) / 2.0
# GridStrain.m:97
                count=count + 1
# GridStrain.m:98
        #Initialize indexes of stations for cells
        inds=zeros(ncells,nstat)
# GridStrain.m:102
        wv=zeros(ncells,dot(nstat,2))
# GridStrain.m:104
        for i in arange(1,ncells).reshape(-1):
            #Initialize distances to nearest stations to -1.0
            dists=dot(ones(1,nstat),- 1.0)
# GridStrain.m:108
            for j in arange(1,size(pos,1)).reshape(-1):
                #Distance from center of cell to station
                distx=cent[i,1] - pos[j,1]
# GridStrain.m:112
                disty=cent[i,2] - pos[j,2]
# GridStrain.m:113
                dist=sqrt(distx ** 2 + disty ** 2)
# GridStrain.m:114
                if k == 1:
                    #If within the specified maximum distance to neighbors
                    if dist <= par[3]:
                        mind,mini=min(dists,nargout=2)
# GridStrain.m:119
                        if mind == - 1.0:
                            dists[mini]=dist
# GridStrain.m:122
                            inds[i,mini]=j
# GridStrain.m:123
                        else:
                            #If current distance is lower than maximum distance
                            maxd,maxi=max(dists,nargout=2)
# GridStrain.m:127
                            if dist < maxd:
                                dists[maxi]=dist
# GridStrain.m:129
                                inds[i,maxi]=j
# GridStrain.m:130
                    #If distance weighted
                else:
                    if k == 2:
                        inds[i,:]=arange(1,nstat)
# GridStrain.m:136
                        #weight factor
                        weight=exp(- dist ** 2 / (dot(2.0,par[2] ** 2)))
# GridStrain.m:138
                        wv[i,dot(j,2) - 1]=weight
# GridStrain.m:139
                        wv[i,dot(j,2)]=weight
# GridStrain.m:140
    
    
    #Initialize arrays
    y=zeros(dot(nstat,2),1)
# GridStrain.m:147
    M=zeros(dot(nstat,2),6)
# GridStrain.m:147
    e=zeros(3,3)
# GridStrain.m:147
    eps=zeros(3,3,ncells)
# GridStrain.m:148
    ome=zeros(3,3,ncells)
# GridStrain.m:148
    pstrains=zeros(3,3,ncells)
# GridStrain.m:149
    rotc=zeros(ncells,3)
# GridStrain.m:149
    #For each cell
    for i in arange(1,ncells).reshape(-1):
        #If required minimum number of stations
        if min(inds[i,:]) > 0:
            #Fill displacements column vector y and design matrix M
        #Use X1 = North, X2 = East
            for j in arange(1,nstat).reshape(-1):
                y[dot(j,2) - 1]=disp[inds[i,j],2]
# GridStrain.m:158
                y[dot(j,2)]=disp[inds[i,j],1]
# GridStrain.m:159
                M[dot(j,2) - 1,:]=cat(1,0,pos[inds[i,j],2],pos[inds[i,j],1],0,0)
# GridStrain.m:160
                M[dot(j,2),:]=cat(0,1,0,0,pos[inds[i,j],2],pos[inds[i,j],1])
# GridStrain.m:161
            #Compute x (Eqs. 8.37 and 8.38): Use MATLAB function lscov
        #If Delaunay or nearest neighbor
            if k == 0 or k == 1:
                x=lscov(M,y)
# GridStrain.m:166
            else:
                if k == 2:
                    x=lscov(M,y,wv[i,:])
# GridStrain.m:169
            #Displacement gradient tensor
            for j in arange(1,2).reshape(-1):
                e[j,1]=x[dot(j,2) + 1]
# GridStrain.m:173
                e[j,2]=x[dot(j,2) + 2]
# GridStrain.m:174
            #Compute strain
            eps[:,:,i],ome[:,:,i],pstrains[:,:,i],rotc[i,:]=InfStrain(e,nargout=4)
# GridStrain.m:177
    
    #Variable to plot
#If maximum principal strain
    if plotpar == 0:
        vp=pstrains[1,1,:]
# GridStrain.m:184
        cbt='e1'
# GridStrain.m:185
        #If minimum principal strain
    else:
        if plotpar == 1:
            vp=pstrains[3,1,:]
# GridStrain.m:188
            cbt='e3'
# GridStrain.m:189
            #If rotation: Since we are assuming plane strain, rotation = rotc(3)
        else:
            if plotpar == 2:
                vp=dot(rotc[:,3],180) / pi
# GridStrain.m:192
                cbt='rot (deg)'
# GridStrain.m:193
                #If dilatation
            else:
                if plotpar == 3:
                    vp=pstrains[1,1,:] + pstrains[2,1,:] + pstrains[3,1,:]
# GridStrain.m:196
                    cbt='dilat'
# GridStrain.m:197
    
    #scale variable to plot so that is between 0 and 1
    minvp=min(vp)
# GridStrain.m:201
    maxvp=max(vp)
# GridStrain.m:201
    rangvp=maxvp - minvp
# GridStrain.m:201
    vps=(vp - minvp) / rangvp
# GridStrain.m:202
    #colormap
    colormap(jet)
    #Plot cells
#If Delaunay
    if k == 0:
        for i in arange(1,ncells).reshape(-1):
            #If required minimum number of stations
            if min(inds[i,:]) > 0:
                xp=matlabarray(cat([pos[inds[i,1],1]],[pos[inds[i,2],1]],[pos[inds[i,3],1]]))
# GridStrain.m:213
                yp=matlabarray(cat([pos[inds[i,1],2]],[pos[inds[i,2],2]],[pos[inds[i,3],2]]))
# GridStrain.m:214
                patch(xp,yp,vps[i],'EdgeColor','k')
    
    #If nearest neighbor or distance weighted
    if k == 1 or k == 2:
        count=1
# GridStrain.m:221
        for i in arange(1,cellsy).reshape(-1):
            for j in arange(1,cellsx).reshape(-1):
                #If required minimum number of stations
                if min(inds[count,:]) > 0:
                    xp=matlabarray(cat(XX[i,j],XX[i,j + 1],XX[i + 1,j + 1],XX[i + 1,j]))
# GridStrain.m:226
                    yp=matlabarray(cat(YY[i,j],YY[i,j + 1],YY[i + 1,j + 1],YY[i + 1,j]))
# GridStrain.m:227
                    patch(xp,yp,vps[count],'EdgeColor','k')
                count=count + 1
# GridStrain.m:230
    
    #colorbar
    ytick=matlabarray(cat(0,0.2,0.4,0.6,0.8,1.0))
# GridStrain.m:236
    cb=colorbar('Ytick',ytick,'YTickLabel',cellarray([num2str(minvp),num2str(minvp + rangvp / 5),num2str(minvp + dot(2,rangvp) / 5),num2str(minvp + dot(3,rangvp) / 5),num2str(minvp + dot(4,rangvp) / 5),num2str(maxvp)]))
# GridStrain.m:237
    set(get(cb,'title'),'String',cbt)
    #Axes
    axis('equal')
    xlabel('x')
    ylabel('y')
    return cent,eps,ome,pstrains,rotc
    
if __name__ == '__main__':
    pass
    