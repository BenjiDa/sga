# Autogenerated with SMOP 
from smop.core import *
# Trishear.m

    
@function
def Trishear(yp=None,psect=None,tparam=None,sinc=None,*args,**kwargs):
    varargin = Trishear.varargin
    nargin = Trishear.nargin

    #Trishear plots the evolution of a 2D trishear fault propagation fold
    
    #   USE: frames = Trishear(yp,psect,tparam,sinc)
    
    #   yp = Datums or vertical coordinates of undeformed, horizontal beds
#   psect = A 1 x 2 vector containing the extent of the section, and the 
#           number of points in each bed 
#   tparam = A 1 x 7 vector containing: the x coordinate of the fault tip 
#           (entry 1), the y coordinate of the fault tip (entry 2), the
#           ramp angle (entry 3), the P/S (entry 4), the trishear angle
#           (entry 5), the fault slip (entry 6), and the concentration
#           factor (entry 7)
#   sinc = slip increment
#   frames = An array structure containing the frames of the fold evolution
#            You can play the movie again just by typing movie(frames)
#   
#   NOTE: Input ramp and trishear angles should be in radians
#         For reverse faults use positive slip and slip increment
#         For normal faults use negative slip and slip increment
    
    #   Trishear uses function VelTrishear
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Extent of section and number of points in each bed
    extent=psect[1]
# Trishear.m:29
    npoint=psect[2]
# Trishear.m:29
    #Make undeformed beds geometry: This is a grid of points along the beds
    xp=arange(0.0,extent,extent / npoint)
# Trishear.m:31
    XP,YP=meshgrid(xp,yp,nargout=2)
# Trishear.m:32
    # Model parameters
    xt=tparam[1]
# Trishear.m:35
    
    yt=tparam[2]
# Trishear.m:36
    
    ramp=tparam[3]
# Trishear.m:37
    
    ps=tparam[4]
# Trishear.m:38
    
    tra=tparam[5]
# Trishear.m:39
    
    m=tan(tra / 2)
# Trishear.m:40
    
    slip=tparam[6]
# Trishear.m:41
    
    c=tparam[7]
# Trishear.m:42
    
    #Number of slip increments
    ninc=round(slip / sinc)
# Trishear.m:44
    #Transformation matrix from geographic to fault coordinates
    a11=cos(ramp)
# Trishear.m:47
    a12=cos(pi / 2 - ramp)
# Trishear.m:48
    a21=cos(pi / 2 + ramp)
# Trishear.m:49
    a22=copy(a11)
# Trishear.m:50
    # Transform to coordinates parallel and perpendicular to the fault, and
# with origin at initial fault tip
    FX=dot((XP - xt),a11) + dot((YP - yt),a12)
# Trishear.m:54
    FY=dot((XP - xt),a21) + dot((YP - yt),a22)
# Trishear.m:55
    #Run trishear model
#Loop over slip increments
    for i in arange(1,ninc).reshape(-1):
        #Loop over number of beds
        for j in arange(1,size(FX,1)).reshape(-1):
            #Loop over number of points in each bed
            for k in arange(1,size(FX,2)).reshape(-1):
                #Solve trishear in a coordinate system attached to current 
            #fault tip (Eq. 11.27)
                xx=FX[j,k] - (dot(dot(ps,i),abs(sinc)))
# Trishear.m:66
                yy=FY[j,k]
# Trishear.m:67
                vx,vy=VelTrishear(xx,yy,sinc,m,c,nargout=2)
# Trishear.m:69
                FX[j,k]=FX[j,k] + vx
# Trishear.m:71
                FY[j,k]=FY[j,k] + vy
# Trishear.m:72
        #Transform back to horizontal-vertical XP, YP coordinates for plotting
        XP=(dot(FX,a11) + dot(FY,a21)) + xt
# Trishear.m:76
        YP=(dot(FX,a12) + dot(FY,a22)) + yt
# Trishear.m:77
        xtf=xt + dot((dot(dot(ps,i),abs(sinc))),cos(ramp))
# Trishear.m:79
        ytf=yt + dot((dot(dot(ps,i),abs(sinc))),sin(ramp))
# Trishear.m:80
        XF=matlabarray(cat(xt,xtf))
# Trishear.m:81
        YF=matlabarray(cat(yt,ytf))
# Trishear.m:82
        axlo=arange(0,300,10)
# Trishear.m:84
        htz=dot(axlo,m)
# Trishear.m:85
        ftz=dot(- axlo,m)
# Trishear.m:86
        XHTZ=(dot(axlo,a11) + dot(htz,a21)) + xtf
# Trishear.m:87
        YHTZ=(dot(axlo,a12) + dot(htz,a22)) + ytf
# Trishear.m:88
        XFTZ=(dot(axlo,a11) + dot(ftz,a21)) + xtf
# Trishear.m:89
        YFTZ=(dot(axlo,a12) + dot(ftz,a22)) + ytf
# Trishear.m:90
        plot(XF,YF,'r-','LineWidth',2)
        hold('on')
        plot(XHTZ,YHTZ,'b-')
        plot(XFTZ,YFTZ,'b-')
        hw=zeros(1,size(XP,2))
# Trishear.m:99
        fw=zeros(1,size(XP,2))
# Trishear.m:100
        xhb=zeros(size(XP,1),size(XP,2))
# Trishear.m:101
        yhb=zeros(size(XP,1),size(XP,2))
# Trishear.m:102
        xfb=zeros(size(XP,1),size(XP,2))
# Trishear.m:103
        yfb=zeros(size(XP,1),size(XP,2))
# Trishear.m:104
        for j in arange(1,size(XP,1)).reshape(-1):
            hw[j]=0.0
# Trishear.m:106
            fw[j]=0.0
# Trishear.m:107
            for k in arange(1,size(XP,2)).reshape(-1):
                #If hanging wall points
                if XP[j,k] <= xt + (YP[j,k] - yt) / tan(ramp):
                    hw[j]=hw[j] + 1
# Trishear.m:111
                    xhb[j,hw[j]]=XP[j,k]
# Trishear.m:112
                    yhb[j,hw[j]]=YP[j,k]
# Trishear.m:113
                else:
                    fw[j]=fw[j] + 1
# Trishear.m:116
                    xfb[j,fw[j]]=XP[j,k]
# Trishear.m:117
                    yfb[j,fw[j]]=YP[j,k]
# Trishear.m:118
            plot(xhb[j,1:1:hw[j]],yhb[j,1:1:hw[j]],'k-')
            plot(xfb[j,1:1:fw[j]],yfb[j,1:1:fw[j]],'k-')
        #Plot settings
        text(dot(0.8,extent),dot(1.75,max(yp)),strcat('Slip = ',num2str(dot(i,sinc))))
        axis('equal')
        axis(cat(0,extent,0,dot(2.0,max(yp))))
        hold('off')
        frames[i]=getframe
# Trishear.m:130
    
    return frames
    
if __name__ == '__main__':
    pass
    