# Autogenerated with SMOP 
from smop.core import *
# Fibers.m

    
@function
def Fibers(imageName=None,kk=None,*args,**kwargs):
    varargin = Fibers.varargin
    nargin = Fibers.nargin

    #Fibers determines the incremental and finite strain history of a fiber in 
#a pressure shadow
    
    #   USE: [cie,pfs] = Fibers(imageName,kk)
    
    #   image = A character corresponding to the image filename, including 
#           extension (eg. = 'fileName.jpg')
#   kk = An integer that indicates whether the fiber is on a cleavage
#        parallel (kk = 0), or cleavage perpendicular (kk = 1) section
#   cie = cummulative incremental elongation: column 1 = Incremental theta,
#         column 2 = cummulative incremental maximum elongation
#   pfs = progressive finite strain history: column 1 = Finite theta, 
#         column 2 = maximum stretch magnitude
    
    #   NOTE: Output theta angles are in radians
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Read and display image
    IMG=imread(imageName)
# Fibers.m:23
    imagesc(IMG)
    #Prompt the user to define a reference plane. If the current reference 
#plane is not satisfactory, the user can re-select the input points
    a='n'
# Fibers.m:28
    while a == 'n':

        clf
        imagesc(IMG)
        hold('on')
        disp('Select two points along the reference plane, from left to right.')
        refpx,refpy=ginput(2,nargout=2)
# Fibers.m:34
        refpx=round(refpx)
# Fibers.m:35
        refpy=round(refpy)
# Fibers.m:36
        plot(refpx,refpy,'--y','LineWidth',1.5)
        a=input_('Would you like to keep the current reference plane? (y/n)  ','s')
# Fibers.m:38

    
    
    #Prompt the user to select the origin and fiber points from the image 
#display. The origin is defined at the center of the porphyroclast.  
#The fiber points are selected sequentially along a single fiber path.  
#If the current fiber path is not satisfactory, the user can re-select the
#input points
    a='n'
# Fibers.m:46
    while a == 'n':

        clf
        imagesc(IMG)
        hold('on')
        plot(refpx,refpy,'--y','LineWidth',1.5)
        disp('Select the origin point, center of porphyroclast.')
        xo,yo=ginput(1,nargout=2)
# Fibers.m:53
        xo=round(xo)
# Fibers.m:54
        yo=round(yo)
# Fibers.m:54
        plot(xo,yo,'ok','MarkerFaceColor','k','MarkerSize',8)
        #Digitize points along fiber
        disp('Digitize points along the fiber')
        disp('Left mouse button picks points')
        disp('Right mouse button picks last point')
        x=matlabarray([])
# Fibers.m:60
        y=matlabarray([])
# Fibers.m:60
        n=0
# Fibers.m:60
        but=1
# Fibers.m:60
        while but == 1:

            n=n + 1
# Fibers.m:62
            xi,yi,but=ginput(1,nargout=3)
# Fibers.m:63
            xi=round(xi)
# Fibers.m:64
            yi=round(yi)
# Fibers.m:65
            plot(xi,yi,'-or','LineWidth',1.5)
            x[n]=xi
# Fibers.m:67
            y[n]=yi
# Fibers.m:67

        a=input_('Would you like to keep the current fiber path? (y/n)  ','s')
# Fibers.m:69

    
    hold('off')
    #Start calculation
    
    #Switch y values from screen coordinates with (0,0) at the upper left
#corner to cartesian coordinates, with (0,0) at the lower left corner
    nrow=size(IMG,1)
# Fibers.m:77
    
    yo=nrow - yo
# Fibers.m:78
    y=nrow - y
# Fibers.m:79
    refpy=nrow - refpy
# Fibers.m:80
    #Set origin of coordinate system at grain origin
    x=x - xo
# Fibers.m:83
    y=y - yo
# Fibers.m:84
    #Rotate all points into a reference frame parallel to X1
    phi=atan((refpy[2] - refpy[1]) / (refpx[2] - refpx[1]))
# Fibers.m:87
    Rot=matlabarray(cat([cos(phi),sin(phi)],[- sin(phi),cos(phi)]))
# Fibers.m:88
    vec=matlabarray(cat([x],[y]))
# Fibers.m:89
    newvec=dot(Rot,vec)
# Fibers.m:90
    x=newvec[1,:]
# Fibers.m:91
    y=newvec[2,:]
# Fibers.m:92
    #Initialize some variables
    cie=zeros(n - 1,2)
# Fibers.m:95
    rotmat=zeros(2,2,n - 1)
# Fibers.m:96
    finmat=zeros(2,2,n - 1)
# Fibers.m:97
    elong=zeros(1,n - 1)
# Fibers.m:98
    C=zeros(2,2,n - 1)
# Fibers.m:99
    pfs=zeros(n - 1,2)
# Fibers.m:100
    #Incremental, inverse modeling of vein (Backwards)
    for i in arange(1,n - 1).reshape(-1):
        #If cleavage parallel section (Eq. 10.21)
        if kk == 0:
            cie[n - i,1]=atan((y[2] - y[1]) / (x[2] - x[1]))
# Fibers.m:106
        else:
            if kk == 1:
                cie[n - i,1]=(atan((dot(2,(dot(x[2],y[2]) - dot(x[1],y[1])))) / (x[2] ** 2 - y[2] ** 2 - x[1] ** 2 + y[1] ** 2))) / 2
# Fibers.m:109
        Beta=matlabarray(cat([cos(cie[n - i,1]),sin(cie[n - i,1])],[- sin(cie[n - i,1]),cos(cie[n - i,1])]))
# Fibers.m:112
        if kk == 0:
            h=matlabarray(cat([x[1]],[y[1]]))
# Fibers.m:116
            H=matlabarray(cat([x[2]],[y[2]]))
# Fibers.m:117
            v0=H - h
# Fibers.m:118
            v1=h / norm(h)
# Fibers.m:119
            v2=v0 / norm(v0)
# Fibers.m:120
            Alpha=acos(dot(v1,v2))
# Fibers.m:121
            initlength=dot(norm(h),cos(Alpha))
# Fibers.m:122
            st1inc=(norm(v0) + initlength) / initlength
# Fibers.m:123
            posmat=matlabarray(cat([st1inc,0],[0,1]))
# Fibers.m:124
        else:
            if kk == 1:
                Bigx1=dot(Beta,cat([x[1]],[y[1]]))
# Fibers.m:127
                Bigx2=dot(Beta,cat([x[2]],[y[2]]))
# Fibers.m:128
                st1inc=(Bigx2[1] / Bigx1[1])
# Fibers.m:129
                st3inc=(Bigx2[2] / Bigx1[2])
# Fibers.m:130
                posmat=matlabarray(cat([st1inc,0],[0,st3inc]))
# Fibers.m:131
        rotmat[:,:,n - i]=dot(dot(Beta.T,posmat),Beta)
# Fibers.m:133
        elong[n - i]=st1inc - 1
# Fibers.m:134
        for j in arange(1,n - i).reshape(-1):
            newposition=numpy.linalg.solve(rotmat[:,:,n - i],cat([x[j + 1]],[y[j + 1]]))
# Fibers.m:136
            x[j]=newposition[1]
# Fibers.m:137
            y[j]=newposition[2]
# Fibers.m:138
    
    #Plot cummulative incremental maximum elongation
    figure
    cie[:,2]=cumsum(elong)
# Fibers.m:144
    
    plot(dot(cie[:,1],180) / pi,cie[:,2],'o')
    xlabel('Theta incremental deg')
    ylabel('Cumulative incremental elongation')
    axis(cat(- 90,90,0,max(cie[:,2]) + 0.5))
    #Compute progressive finite strain (Forward)
    finmat[:,:,1]=rotmat[:,:,1]
# Fibers.m:151
    for i in arange(2,n - 1).reshape(-1):
        finmat[:,:,i]=dot(rotmat[:,:,i],finmat[:,:,i - 1])
# Fibers.m:153
    
    #Determine Cauchy deformation tensor
    for i in arange(1,n - 1).reshape(-1):
        C[:,:,i]=dot(finmat[:,:,i].T,finmat[:,:,i])
# Fibers.m:157
        #corresponding eigenvectors of Cauchy's tensor. Use MATLAB function eig
        V,D=eig(C[:,:,i],nargout=2)
# Fibers.m:160
        pfs[i,2]=sqrt(D[2,2])
# Fibers.m:161
        pfs[i,1]=atan(V[2,2] / V[1,2])
# Fibers.m:162
    
    #Plot Progresive finite strain
    figure
    plot(dot(pfs[:,1],180) / pi,pfs[:,2],'o')
    xlabel('Theta finite deg')
    ylabel('Progressive Finite Strain')
    axis(cat(- 90,90,1,max(pfs[:,2]) + 0.5))
    return cie,pfs
    
if __name__ == '__main__':
    pass
    