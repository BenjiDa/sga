# Autogenerated with SMOP 
from smop.core import *
# FixedAxisFPF.m

    
@function
def FixedAxisFPF(yp=None,psect=None,pramp=None,pslip=None,*args,**kwargs):
    varargin = FixedAxisFPF.varargin
    nargin = FixedAxisFPF.nargin

    #FixedAxisFPF plots the evolution of a simple step, fixed axis
#fault propagation fold
    
    #   USE: frames = FixedAxisFPF(yp,psect,pramp,pslip)
    
    #   yp = Datums or vertical coordinates of undeformed, horizontal beds
#   psect = A 1 x 2 vector containing the extent of the section, and the 
#           number of points in each bed
#   pramp = A 1 x 2 vector containing the x coordinate of the lower bend in
#           the decollement, and the ramp angle
#   pslip = A 1 x 2 vector containing the total and incremental slip
#   frames = An array structure containing the frames of the fold evolution
#            You can play the movie again just by typing movie(frames)
#   
#   NOTE: Input ramp angle should be in radians
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    # Base of layers
    base=yp[1]
# FixedAxisFPF.m:23
    #Extent of section and number of points in each bed
    extent=psect[1]
# FixedAxisFPF.m:26
    npoint=psect[2]
# FixedAxisFPF.m:26
    #Make undeformed beds geometry: This is a grid of points along the beds
    xp=arange(0.0,extent,extent / npoint)
# FixedAxisFPF.m:28
    XP,YP=meshgrid(xp,yp,nargout=2)
# FixedAxisFPF.m:29
    #Fault geometry and slip
    xramp=pramp[1]
# FixedAxisFPF.m:32
    ramp=pramp[2]
# FixedAxisFPF.m:32
    slip=pslip[1]
# FixedAxisFPF.m:33
    sinc=pslip[2]
# FixedAxisFPF.m:33
    #Number of slip increments
    ninc=round(slip / sinc)
# FixedAxisFPF.m:35
    #Solve model parameters
#First equation of Eq. 11.16
    gam1=(pi - ramp) / 2.0
# FixedAxisFPF.m:39
    #Second equation of Eq. 11.16
    gamestar=acot((3.0 - dot(2.0,cos(ramp))) / (dot(2.0,sin(ramp))))
# FixedAxisFPF.m:41
    #Third equation of Eq. 11.16
    gamistar=gam1 - gamestar
# FixedAxisFPF.m:43
    #Fourth equation of Eq. 11.16
    game=acot(cot(gamestar) - dot(2.0,cot(gam1)))
# FixedAxisFPF.m:45
    #Fifth equation of Eq. 11.16
    gami=asin((dot(sin(gamistar),sin(game))) / sin(gamestar))
# FixedAxisFPF.m:47
    #Ratio of backlimb length to total slip (P/S)(Eq. 11.17)
    a1=cot(gamestar) - cot(gam1)
# FixedAxisFPF.m:49
    a2=1.0 / sin(ramp) - (sin(gami) / sin(game)) / sin(game + gami - ramp)
# FixedAxisFPF.m:50
    a3=sin(gam1 + ramp) / sin(gam1)
# FixedAxisFPF.m:51
    lbrat=a1 / a2 + a3
# FixedAxisFPF.m:52
    #Change in slip between domains 2 and 3 (Eq. 11.19)
    R=sin(gam1 + ramp) / sin(gam1 + game)
# FixedAxisFPF.m:54
    #From the origin of each bed compute the number of points that are in the
#hanging wall. These points are the ones that will move. Notice that this
#has to bee done for each slip increment, since the fault propagates
    hwid=zeros(ninc,size(yp,2))
# FixedAxisFPF.m:59
    for i in arange(1,ninc).reshape(-1):
        uplift=dot(dot(dot(lbrat,i),sinc),sin(ramp))
# FixedAxisFPF.m:61
        for j in arange(1,size(yp,2)).reshape(-1):
            if yp[j] - base <= uplift:
                hwid[i,j]=0
# FixedAxisFPF.m:64
                for k in arange(1,size(xp,2)).reshape(-1):
                    if xp[k] <= xramp + (yp[j] - base) / tan(ramp):
                        hwid[i,j]=hwid[i,j] + 1
# FixedAxisFPF.m:67
            else:
                hwid[i,j]=size(xp,2)
# FixedAxisFPF.m:71
    
    #Deform beds. Apply velocity fields of Eq. 11.18
#Loop over slip increments
    for i in arange(1,ninc).reshape(-1):
        # Compute uplift
        lb=dot(dot(lbrat,i),sinc)
# FixedAxisFPF.m:80
        uplift=dot(lb,sin(ramp))
# FixedAxisFPF.m:81
        lbh=dot(lb,cos(ramp))
# FixedAxisFPF.m:82
        xt=xramp + lbh
# FixedAxisFPF.m:84
        yt=base + uplift
# FixedAxisFPF.m:85
        for j in arange(1,size(XP,1)).reshape(-1):
            #Loop over number of hanging wall points in each bed
            for k in arange(1,hwid[i,j]).reshape(-1):
                #If point is in domain 1
                if XP[j,k] < xramp - (YP[j,k] - base) / tan(gam1):
                    XP[j,k]=XP[j,k] + sinc
# FixedAxisFPF.m:92
                else:
                    #If point is in domain 2
                    if XP[j,k] < xt - (YP[j,k] - yt) / tan(gam1):
                        XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# FixedAxisFPF.m:96
                        YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# FixedAxisFPF.m:97
                    else:
                        #If point is in domain 3
                        if XP[j,k] < xt + (YP[j,k] - yt) / tan(game):
                            XP[j,k]=XP[j,k] + dot(dot(sinc,R),cos(game))
# FixedAxisFPF.m:101
                            YP[j,k]=YP[j,k] + dot(dot(sinc,R),sin(game))
# FixedAxisFPF.m:102
        #Plot increment
    #Fault
        xf=matlabarray(cat(0,xramp,xramp + lbh))
# FixedAxisFPF.m:110
        yf=matlabarray(cat(base,base,uplift + base))
# FixedAxisFPF.m:111
        plot(xf,yf,'r-','LineWidth',2)
        hold('on')
        for j in arange(1,size(yp,2)).reshape(-1):
            #If beds cut by the fault
            if yp[j] - base <= uplift:
                plot(XP[j,1:1:hwid[i,j]],YP[j,1:1:hwid[i,j]],'k-')
                plot(XP[j,hwid[i,j] + 1:1:size(xp,2)],YP[j,hwid[i,j] + 1:1:size(xp,2)],'k-')
            else:
                plot(XP[j,:],YP[j,:],'k-')
        #Plot settings
        text(dot(0.8,extent),dot(1.75,max(yp)),strcat('Slip = ',num2str(dot(i,sinc))))
        axis('equal')
        axis(cat(0,extent,0,dot(2.0,max(yp))))
        hold('off')
        frames[i]=getframe
# FixedAxisFPF.m:132
    
    return frames
    
if __name__ == '__main__':
    pass
    