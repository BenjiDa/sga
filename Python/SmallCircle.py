# Autogenerated with SMOP 
from smop.core import *
# SmallCircle.m

    
@function
def SmallCircle(trda=None,plga=None,coneAngle=None,sttype=None,*args,**kwargs):
    varargin = SmallCircle.varargin
    nargin = SmallCircle.nargin

    #SmallCircle computes the paths of a small circle defined by its axis and
#cone angle, for an equal angle or equal area stereonet of unit radius
    
    #   USE: [path1,path2,np1,np2] = SmallCircle(trda,plga,coneAngle,sttype)
    
    #   trda = trend of axis
#   plga = plunge of axis
#   coneAngle = cone angle
#   sttype = type of stereonet. 0 for equal angle and 1 for equal area
#   path1 and path2 = vectors with the x and y coordinates of the points
#                     in the small circle paths
#   np1 and np2 = Number of points in path1 and path2, respectively
    
    #   NOTE: All angles should be in radians
    
    #   SmallCircle uses functions ZeroTwoPi, StCoordLine and Rotate
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Find where to start the small circle
    if (plga - coneAngle) >= 0.0:
        trd=copy(trda)
# SmallCircle.m:25
        plg=plga - coneAngle
# SmallCircle.m:26
    else:
        if plga == pi / 2.0:
            plga=dot(plga,0.9999)
# SmallCircle.m:29
        angle=acos(cos(coneAngle) / cos(plga))
# SmallCircle.m:31
        trd=ZeroTwoPi(trda + angle)
# SmallCircle.m:32
        plg=0.0
# SmallCircle.m:33
    
    #To make the small circle, rotate the starting line 360 degrees in
#increments of 1 degree
    rot=dot((arange(0,360,1)),pi) / 180
# SmallCircle.m:38
    path1=zeros(size(rot,2),2)
# SmallCircle.m:39
    path2=zeros(size(rot,2),2)
# SmallCircle.m:40
    np1=0
# SmallCircle.m:41
    np2=0
# SmallCircle.m:41
    for i in arange(1,size(rot,2)).reshape(-1):
        #Rotate line: Notice that here the line is considered as a vector
        rtrd,rplg=Rotate(trda,plga,rot[i],trd,plg,'v',nargout=2)
# SmallCircle.m:44
        # If plunge of rotated line is positive add to first path
        if rplg >= 0.0:
            np1=np1 + 1
# SmallCircle.m:48
            path1[np1,1],path1[np1,2]=StCoordLine(rtrd,rplg,sttype,nargout=2)
# SmallCircle.m:50
        else:
            np2=np2 + 1
# SmallCircle.m:53
            path2[np2,1],path2[np2,2]=StCoordLine(rtrd,rplg,sttype,nargout=2)
# SmallCircle.m:55
    
    return path1,path2,np1,np2
    
if __name__ == '__main__':
    pass
    