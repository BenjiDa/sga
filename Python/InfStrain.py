# Autogenerated with SMOP 
from smop.core import *
# InfStrain.m

    
@function
def InfStrain(e=None,*args,**kwargs):
    varargin = InfStrain.varargin
    nargin = InfStrain.nargin

    #InfStrain computes infinitesimal strain from an input displacement
#gradient tensor
    
    #   USE: [eps,ome,pstrains,rotc,rot] = InfStrain(e)
    
    #   e = 3 x 3 displacement gradient tensor
#   eps = 3 x 3 strain tensor
#   ome = 3 x 3 rotation tensor
#   pstrains = 3 x 3 matrix with magnitude (column 1), trend (column 2) and
#              plunge (column 3) of maximum (row 1), intermediate (row 2),
#              and minimum (row 3) principal strains
#   rotc = 1 x 3 vector with rotation components
#   rot = 1 x 3 vector with rotation magnitude and trend and plunge of
#          rotation axis
    
    #   NOTE: Output trends and plunges of principal strains and rotation axes
#   are in radians
    
    #   InfStrain uses function CartToSph and ZeroTwoPi
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Initialize variables
    eps=zeros(3,3)
# InfStrain.m:27
    ome=zeros(3,3)
# InfStrain.m:28
    pstrains=zeros(3,3)
# InfStrain.m:29
    rotc=zeros(1,3)
# InfStrain.m:30
    rot=zeros(1,3)
# InfStrain.m:31
    #Compute strain and rotation tensors (Eq. 8.2)
    for i in arange(1,3).reshape(-1):
        for j in arange(1,3).reshape(-1):
            eps[i,j]=dot(0.5,(e[i,j] + e[j,i]))
# InfStrain.m:36
            ome[i,j]=dot(0.5,(e[i,j] - e[j,i]))
# InfStrain.m:37
    
    #Compute principal strains and orientations. Here we use the MATLAB
#function eig. D is a diagonal matrix of eigenvalues (i.e. principal 
#strains), and V is a full matrix whose columns are the corresponding 
#eigenvectors (i.e. principal strain directions)
    V,D=eig(eps,nargout=2)
# InfStrain.m:45
    #Maximum principal strain
    pstrains[1,1]=D[3,3]
# InfStrain.m:48
    pstrains[1,2],pstrains[1,3]=CartToSph(V[1,3],V[2,3],V[3,3],nargout=2)
# InfStrain.m:49
    #Intermediate principal strain
    pstrains[2,1]=D[2,2]
# InfStrain.m:51
    pstrains[2,2],pstrains[2,3]=CartToSph(V[1,2],V[2,2],V[3,2],nargout=2)
# InfStrain.m:52
    #Minimum principal strain
    pstrains[3,1]=D[1,1]
# InfStrain.m:54
    pstrains[3,2],pstrains[3,3]=CartToSph(V[1,1],V[2,1],V[3,1],nargout=2)
# InfStrain.m:55
    #Calculate rotation components (Eq. 8.4)
    rotc[1]=dot((ome[2,3] - ome[3,2]),- 0.5)
# InfStrain.m:58
    rotc[2]=dot((- ome[1,3] + ome[3,1]),- 0.5)
# InfStrain.m:59
    rotc[3]=dot((ome[1,2] - ome[2,1]),- 0.5)
# InfStrain.m:60
    #Compute rotation magnitude (Eq. 8.5)
    rot[1]=sqrt(rotc[1] ** 2 + rotc[2] ** 2 + rotc[3] ** 2)
# InfStrain.m:63
    #Compute trend and plunge of rotation axis
    rot[2],rot[3]=CartToSph(rotc[1] / rot[1],rotc[2] / rot[1],rotc[3] / rot[1],nargout=2)
# InfStrain.m:65
    #If plunge is negative
    if rot[3] < 0.0:
        rot[2]=ZeroTwoPi(rot[2] + pi)
# InfStrain.m:68
        rot[3]=- rot[3]
# InfStrain.m:69
        rot[1]=- rot[1]
# InfStrain.m:70
    
    return eps,ome,pstrains,rotc,rot
    
if __name__ == '__main__':
    pass
    