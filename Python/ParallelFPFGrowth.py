# Autogenerated with SMOP 
from smop.core import *
# ParallelFPFGrowth.m

    
@function
def ParallelFPFGrowth(yp=None,psect=None,pramp=None,pslip=None,G=None,*args,**kwargs):
    varargin = ParallelFPFGrowth.varargin
    nargin = ParallelFPFGrowth.nargin

    #ParallelFPF plots the evolution of a simple step, parallel
#fault propagation fold and adds growth strata for a given subsidence
#versus uplift rate
    
    #   USE: frames = ParallelFPFGrowth(yp,psect,pramp,pslip,G)
    
    #   yp = Datums or vertical coordinates of undeformed, horizontal beds
#   psect = A 1 x 2 vector containing the extent of the section, and the 
#           number of points in each bed 
#   pramp = A 1 x 2 vector containing the x coordinate of the lower bend in
#           the decollement, and the ramp angle 
#   pslip = A 1 x 2 vector containing the total and incremental slip
#   G = Subsidence versus uplift rate
#   frames = An array structure containing the frames of the fold evolution
#            You can play the movie again just by typing movie(frames)
#   
#   NOTE: Input ramp angle should be in radians
    
    #   ParallelFPFGrowth uses function SuppeEquationTwo
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    # Base of layers
    base=yp[1]
# ParallelFPFGrowth.m:27
    #Top of layers
    top=yp[max(size(yp))]
# ParallelFPFGrowth.m:29
    #Extent of section and number of points in each bed
    extent=psect[1]
# ParallelFPFGrowth.m:32
    npoint=psect[2]
# ParallelFPFGrowth.m:32
    #Make undeformed beds geometry: This is a grid of points along the beds
    xp=arange(0.0,extent,extent / npoint)
# ParallelFPFGrowth.m:34
    XP,YP=meshgrid(xp,yp,nargout=2)
# ParallelFPFGrowth.m:35
    #Fault geometry and slip
    xramp=pramp[1]
# ParallelFPFGrowth.m:38
    ramp=pramp[2]
# ParallelFPFGrowth.m:38
    slip=pslip[1]
# ParallelFPFGrowth.m:39
    sinc=pslip[2]
# ParallelFPFGrowth.m:39
    #Number of slip increments
    ninc=round(slip / sinc)
# ParallelFPFGrowth.m:41
    # Make ten growth strata
    nincG=round(ninc / 10)
# ParallelFPFGrowth.m:44
    # Initialize count of growth strata to 1
    countG=1
# ParallelFPFGrowth.m:46
    #Solve model parameters
#Solve first equation in Eq. 11.20 by minimizing SuppeEquationTwo
    options=optimset('display','off')
# ParallelFPFGrowth.m:50
    gamstar=fzero('SuppeEquationTwo',0.5,options,ramp)
# ParallelFPFGrowth.m:51
    #Solve second equation in Eq. 11.20
    gam1=pi / 2.0 - ramp / 2.0
# ParallelFPFGrowth.m:53
    #Solve third equation in Eq. 11.20
    gam=pi / 2.0 + gamstar - gam1
# ParallelFPFGrowth.m:55
    #Solve fourth equation in Eq. 11.20
    bet2=pi - dot(2.0,gamstar)
# ParallelFPFGrowth.m:57
    #Other angle for computation
    kap=pi - bet2 + ramp
# ParallelFPFGrowth.m:59
    #Eq. 11.21
    lbrat=1.0 / (1.0 - sin(ramp) / sin(dot(2.0,gam) - ramp))
# ParallelFPFGrowth.m:61
    #Eq. 11.23
    R1=sin(gam1 + ramp) / sin(gam1 + gam)
# ParallelFPFGrowth.m:63
    R2=sin(bet2) / sin(bet2 - ramp + gam)
# ParallelFPFGrowth.m:64
    # Incremental Crestal uplift. Eq. 15 of Hardy and Poblet (2005)
    inccrupl=dot((sin(gam1) / sin(gam1 + gam)),sin(gam))
# ParallelFPFGrowth.m:66
    #From the origin of each bed compute the number of points that are in the
#hanging wall. These points are the ones that will move. Notice that this
#has to bee done for each slip increment, since the fault propagates
    hwid=zeros(ninc,size(yp,2))
# ParallelFPFGrowth.m:73
    for i in arange(1,ninc).reshape(-1):
        uplift=dot(dot(dot(lbrat,i),sinc),sin(ramp))
# ParallelFPFGrowth.m:75
        for j in arange(1,size(yp,2)).reshape(-1):
            if yp[j] - base <= uplift:
                hwid[i,j]=0
# ParallelFPFGrowth.m:78
                for k in arange(1,size(xp,2)).reshape(-1):
                    if xp[k] <= xramp + (yp[j] - base) / tan(ramp):
                        hwid[i,j]=hwid[i,j] + 1
# ParallelFPFGrowth.m:81
            else:
                hwid[i,j]=size(xp,2)
# ParallelFPFGrowth.m:85
    
    #Deform beds: Apply velocity fields of Eq. 11.22
#Loop over slip increments
    for i in arange(1,ninc).reshape(-1):
        # Compute uplift
        lb=dot(dot(lbrat,i),sinc)
# ParallelFPFGrowth.m:94
        uplift=dot(lb,sin(ramp))
# ParallelFPFGrowth.m:95
        lbh=dot(lb,cos(ramp))
# ParallelFPFGrowth.m:96
        ef=uplift / sin(dot(2.0,gamstar))
# ParallelFPFGrowth.m:98
        xt=xramp + lbh
# ParallelFPFGrowth.m:100
        yt=base + uplift
# ParallelFPFGrowth.m:101
        xe=xt + dot(ef,cos(kap))
# ParallelFPFGrowth.m:103
        ye=yt + dot(ef,sin(kap))
# ParallelFPFGrowth.m:104
        for j in arange(1,size(XP,1)).reshape(-1):
            #number of hanging wall points in bed 
        #If pregrowth bed
            if j <= size(yp,2):
                points=hwid[i,j]
# ParallelFPFGrowth.m:110
            else:
                points=size(XP,2)
# ParallelFPFGrowth.m:113
            #Loop over number of hanging wall points in each bed
            for k in arange(1,points).reshape(-1):
                #If point is in domain 1
                if XP[j,k] < xramp - (YP[j,k] - base) / tan(gam1):
                    XP[j,k]=XP[j,k] + sinc
# ParallelFPFGrowth.m:119
                else:
                    # if y lower than y at e
                    if YP[j,k] < ye:
                        #If point is in domain 2
                        if XP[j,k] < xt + (YP[j,k] - yt) / tan(kap):
                            XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# ParallelFPFGrowth.m:125
                            YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# ParallelFPFGrowth.m:126
                        else:
                            #If point is in domain 4
                            if XP[j,k] < xt + (YP[j,k] - yt) / tan(gam):
                                XP[j,k]=XP[j,k] + dot(dot(sinc,R2),cos(gam))
# ParallelFPFGrowth.m:130
                                YP[j,k]=YP[j,k] + dot(dot(sinc,R2),sin(gam))
# ParallelFPFGrowth.m:131
                        # if y higher than y at e
                    else:
                        #If point is in domain 2
                        if XP[j,k] < xe - (YP[j,k] - ye) / tan(gam1):
                            XP[j,k]=XP[j,k] + dot(sinc,cos(ramp))
# ParallelFPFGrowth.m:138
                            YP[j,k]=YP[j,k] + dot(sinc,sin(ramp))
# ParallelFPFGrowth.m:139
                        else:
                            #If point is in domain 3
                            if XP[j,k] < xe + (YP[j,k] - ye) / tan(gam):
                                XP[j,k]=XP[j,k] + dot(dot(sinc,R1),cos(gam))
# ParallelFPFGrowth.m:143
                                YP[j,k]=YP[j,k] + dot(dot(sinc,R1),sin(gam))
# ParallelFPFGrowth.m:144
                            else:
                                #If point is in domain 4
                                if XP[j,k] < xt + (YP[j,k] - yt) / tan(gam):
                                    XP[j,k]=XP[j,k] + dot(dot(sinc,R2),cos(gam))
# ParallelFPFGrowth.m:148
                                    YP[j,k]=YP[j,k] + dot(dot(sinc,R2),sin(gam))
# ParallelFPFGrowth.m:149
        #Plot increment
    #Fault
        xf=matlabarray(cat(0,xramp,xramp + lbh))
# ParallelFPFGrowth.m:160
        yf=matlabarray(cat(base,base,uplift + base))
# ParallelFPFGrowth.m:161
        plot(xf,yf,'r-','LineWidth',2)
        hold('on')
        for j in arange(1,size(yp,2)).reshape(-1):
            #If Beds cut by the fault
            if yp[j] - base <= uplift:
                plot(XP[j,1:1:hwid[i,j]],YP[j,1:1:hwid[i,j]],'k-')
                plot(XP[j,hwid[i,j] + 1:1:size(xp,2)],YP[j,hwid[i,j] + 1:1:size(xp,2)],'k-')
            else:
                plot(XP[j,:],YP[j,:],'k-')
        # Growth beds
        for j in arange(size(yp,2) + 1,size(XP,1)).reshape(-1):
            plot(XP[j,:],YP[j,:],'g-')
        #Plot settings
        text(dot(0.8,extent),dot(2.75,max(yp)),strcat('Slip = ',num2str(dot(i,sinc))))
        axis('equal')
        axis(cat(0,extent,0,dot(3.0,max(yp))))
        hold('off')
        frames[i]=getframe
# ParallelFPFGrowth.m:186
        #are not calculated. Growth strata will not look right for subsidence
    #rate lower than uplift rate G < 1.0
        if (i == dot(countG,nincG)):
            # Make growth strata
        # Update top
            top=top + dot(dot(dot(nincG,sinc),inccrupl),G)
# ParallelFPFGrowth.m:193
            xp=arange(dot(i,sinc),extent + dot(i,sinc),extent / npoint)
# ParallelFPFGrowth.m:195
            GXP,GYP=meshgrid(xp,top,nargout=2)
# ParallelFPFGrowth.m:196
            XP=matlabarray(cat([XP],[GXP]))
# ParallelFPFGrowth.m:198
            YP=matlabarray(cat([YP],[GYP]))
# ParallelFPFGrowth.m:199
            countG=countG + 1
# ParallelFPFGrowth.m:201
    
    return frames
    
if __name__ == '__main__':
    pass
    