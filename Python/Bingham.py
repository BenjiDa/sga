# Autogenerated with SMOP 
from smop.core import *
# Bingham.m

    
@function
def Bingham(T=None,P=None,*args,**kwargs):
    varargin = Bingham.varargin
    nargin = Bingham.nargin

    #Bingham calculates and plots a cylindrical best fit to a pole distribution
#to find fold axes from poles to bedding or the orientation of a plane from
#two apparent dips. The statistical routine is based on algorithms in
#Fisher et al. (1988)
    
    #   USE: [eigVec,confCone,bestFit] = Bingham(T,P)
    
    #   T and P = Vectors of lines trends and plunges respectively
    
    #   eigVec= 3 x 3 matrix with eigenvalues (column 1), and trends (column 2)
#   and plunges (column 3) of the eigenvectors. Maximum eigenvalue and 
#   corresponding eigenvector are in row 1, intermediate in row 2, 
#   and minimum in row 3.
    
    #   confCone = 2 x 2 matrix with the maximum (column 1) and minimum 
#   (column 2) radius of the 95# elliptical confidence cone around the 
#   eigenvector corresponding to the largest (row 1), and lowest (row 2) 
#   eigenvalue
    
    #   besFit = 1 x 2 vector containing the strike and dip (right hand rule) 
#   of the best fit great circle to the distribution of lines
    
    #   NOTE: Input/Output trends and plunges, as well as confidence
#   cones are in radians. Bingham plots the input lines, eigenvectors and
#   best fit great circle in an equal area stereonet.
#   
#   Bingham uses functions ZeroTwoPi, SphToCart, CartToSph, Stereonet, 
#   StCoordLine and GreatCircle
    
    #MATLAB script written by Nestor Cardozo for the book Structural 
#Geology Algorithms by Allmendinger, Cardozo, & Fisher, 2011. If you use
#this script, please cite this as "Cardozo in Allmendinger et al. (2011)"
    
    #Some constants
    east=pi / 2.0
# Bingham.m:36
    twopi=dot(pi,2.0)
# Bingham.m:37
    #Number of lines
    nlines=max(size(T))
# Bingham.m:40
    #Initialize the orientation matrix
    a=zeros(3,3)
# Bingham.m:43
    #Fill the orientation matrix with the sums of the squares (for the 
#principal diagonal) and the products of the direction cosines of each
#line. cn, ce and cd are the north, east and down direction cosines
    for i in arange(1,nlines).reshape(-1):
        cn,ce,cd=SphToCart(T[i],P[i],0,nargout=3)
# Bingham.m:49
        a[1,1]=a[1,1] + dot(cn,cn)
# Bingham.m:50
        a[1,2]=a[1,2] + dot(cn,ce)
# Bingham.m:51
        a[1,3]=a[1,3] + dot(cn,cd)
# Bingham.m:52
        a[2,2]=a[2,2] + dot(ce,ce)
# Bingham.m:53
        a[2,3]=a[2,3] + dot(ce,cd)
# Bingham.m:54
        a[3,3]=a[3,3] + dot(cd,cd)
# Bingham.m:55
    
    #The orientation matrix is symmetric so the off-diagonal components can be
#equated
    a[2,1]=a[1,2]
# Bingham.m:60
    a[3,1]=a[1,3]
# Bingham.m:61
    a[3,2]=a[2,3]
# Bingham.m:62
    #Calculate the eigenvalues and eigenvectors of the orientation matrix using
#MATLAB function eig. D is a diagonal matrix of eigenvalues and V is a 
#full matrix whose columns are the corresponding eigenvectors
    V,D=eig(a,nargout=2)
# Bingham.m:67
    #Normalize the eigenvalues by the number of lines and convert the
#corresponding eigenvectors to the lower hemisphere
    for i in arange(1,3).reshape(-1):
        D[i,i]=D[i,i] / nlines
# Bingham.m:72
        if V[3,i] < 0.0:
            V[1,i]=- V[1,i]
# Bingham.m:74
            V[2,i]=- V[2,i]
# Bingham.m:75
            V[3,i]=- V[3,i]
# Bingham.m:76
    
    #Initialize eigVec
    eigVec=zeros(3,3)
# Bingham.m:81
    #Fill eigVec
    eigVec[1,1]=D[3,3]
# Bingham.m:83
    
    eigVec[2,1]=D[2,2]
# Bingham.m:84
    
    eigVec[3,1]=D[1,1]
# Bingham.m:85
    
    #Trend and plunge of largest eigenvalue: column 3 of V
    eigVec[1,2],eigVec[1,3]=CartToSph(V[1,3],V[2,3],V[3,3],nargout=2)
# Bingham.m:87
    #Trend and plunge of intermediate eigenvalue: column 2 of V
    eigVec[2,2],eigVec[2,3]=CartToSph(V[1,2],V[2,2],V[3,2],nargout=2)
# Bingham.m:89
    #Trend and plunge of minimum eigenvalue: column 1 of V
    eigVec[3,2],eigVec[3,3]=CartToSph(V[1,1],V[2,1],V[3,1],nargout=2)
# Bingham.m:91
    #Initialize confCone
    confCone=zeros(2,2)
# Bingham.m:94
    #If there are more than 25 lines, calculate confidence cones at the 95#
#confidence level. The algorithm is explained in Fisher et al. (1998)
    if nlines >= 25:
        e11=0.0
# Bingham.m:98
        e22=0.0
# Bingham.m:99
        e12=0.0
# Bingham.m:100
        d11=0.0
# Bingham.m:101
        d22=0.0
# Bingham.m:102
        d12=0.0
# Bingham.m:103
        en11=1.0 / (dot(nlines,(eigVec[3,1] - eigVec[1,1]) ** 2))
# Bingham.m:104
        en22=1.0 / (dot(nlines,(eigVec[2,1] - eigVec[1,1]) ** 2))
# Bingham.m:105
        en12=1.0 / (dot(dot(nlines,(eigVec[3,1] - eigVec[1,1])),(eigVec[2,1] - eigVec[1,1])))
# Bingham.m:106
        dn11=copy(en11)
# Bingham.m:108
        dn22=1.0 / (dot(nlines,(eigVec[3,1] - eigVec[2,1]) ** 2))
# Bingham.m:109
        dn12=1.0 / (dot(dot(nlines,(eigVec[3,1] - eigVec[2,1])),(eigVec[3,1] - eigVec[1,1])))
# Bingham.m:110
        vec=zeros(3,3)
# Bingham.m:112
        for i in arange(1,3).reshape(-1):
            vec[i,1]=dot(sin(eigVec[i,3] + east),cos(twopi - eigVec[i,2]))
# Bingham.m:114
            vec[i,2]=dot(sin(eigVec[i,3] + east),sin(twopi - eigVec[i,2]))
# Bingham.m:115
            vec[i,3]=cos(eigVec[i,3] + east)
# Bingham.m:116
        for i in arange(1,nlines).reshape(-1):
            c1=dot(sin(P[i] + east),cos(twopi - T[i]))
# Bingham.m:119
            c2=dot(sin(P[i] + east),sin(twopi - T[i]))
# Bingham.m:120
            c3=cos(P[i] + east)
# Bingham.m:121
            u1x=dot(vec[3,1],c1) + dot(vec[3,2],c2) + dot(vec[3,3],c3)
# Bingham.m:122
            u2x=dot(vec[2,1],c1) + dot(vec[2,2],c2) + dot(vec[2,3],c3)
# Bingham.m:123
            u3x=dot(vec[1,1],c1) + dot(vec[1,2],c2) + dot(vec[1,3],c3)
# Bingham.m:124
            e11=dot(dot(dot(u1x,u1x),u3x),u3x) + e11
# Bingham.m:125
            e22=dot(dot(dot(u2x,u2x),u3x),u3x) + e22
# Bingham.m:126
            e12=dot(dot(dot(u1x,u2x),u3x),u3x) + e12
# Bingham.m:127
            d11=copy(e11)
# Bingham.m:128
            d22=dot(dot(dot(u1x,u1x),u2x),u2x) + d22
# Bingham.m:129
            d12=dot(dot(dot(u2x,u3x),u1x),u1x) + d12
# Bingham.m:130
        e22=dot(en22,e22)
# Bingham.m:132
        e11=dot(en11,e11)
# Bingham.m:133
        e12=dot(en12,e12)
# Bingham.m:134
        d22=dot(dn22,d22)
# Bingham.m:135
        d11=dot(dn11,d11)
# Bingham.m:136
        d12=dot(dn12,d12)
# Bingham.m:137
        d=dot(- 2.0,log(0.05)) / nlines
# Bingham.m:138
        f=zeros(2,2)
# Bingham.m:140
        if abs(dot(e11,e22) - dot(e12,e12)) >= 1e-06:
            f[1,1]=dot((1 / (dot(e11,e22) - dot(e12,e12))),e22)
# Bingham.m:142
            f[2,2]=dot((1 / (dot(e11,e22) - dot(e12,e12))),e11)
# Bingham.m:143
            f[1,2]=dot(- (1 / (dot(e11,e22) - dot(e12,e12))),e12)
# Bingham.m:144
            f[2,1]=f[1,2]
# Bingham.m:145
            #MATLAB function eig. The next lines follow steps 1-4 outlined on 
        #pp. 34-35 of Fisher et al. (1988)
            DD=eig(f)
# Bingham.m:149
            if DD[1] > 0.0 and DD[2] > 0.0:
                if d / DD[1] <= 1.0 and d / DD[2] <= 1.0:
                    confCone[1,2]=asin(sqrt(d / DD[2]))
# Bingham.m:152
                    confCone[1,1]=asin(sqrt(d / DD[1]))
# Bingham.m:153
        # Repeat the process for the eigenvector corresponding to the smallest
    # eigenvalue
        if abs(dot(d11,d22) - dot(d12,d12)) >= 1e-06:
            f[1,1]=dot((1 / (dot(d11,d22) - dot(d12,d12))),d22)
# Bingham.m:160
            f[2,2]=dot((1 / (dot(d11,d22) - dot(d12,d12))),d11)
# Bingham.m:161
            f[1,2]=dot(- (1 / (dot(d11,d22) - dot(d12,d12))),d12)
# Bingham.m:162
            f[2,1]=f[1,2]
# Bingham.m:163
            DD=eig(f)
# Bingham.m:164
            if DD[1] > 0.0 and DD[2] > 0.0:
                if d / DD[1] <= 1.0 and d / DD[2] <= 1.0:
                    confCone[2,2]=asin(sqrt(d / DD[2]))
# Bingham.m:167
                    confCone[2,1]=asin(sqrt(d / DD[1]))
# Bingham.m:168
    
    #Calculate the best fit great circle to the distribution of points
    bestFit=zeros(1,2)
# Bingham.m:175
    bestFit[1]=ZeroTwoPi(eigVec[3,2] + east)
# Bingham.m:176
    bestFit[2]=east - eigVec[3,3]
# Bingham.m:177
    #Plot stereonet
    Stereonet(0,dot(90,pi) / 180,dot(10,pi) / 180,1)
    #Plot lines
    hold('on')
    for i in arange(1,nlines).reshape(-1):
        xp,yp=StCoordLine(T[i],P[i],1,nargout=2)
# Bingham.m:185
        plot(xp,yp,'k.')
    
    #Plot eigenvectors
    for i in arange(1,3).reshape(-1):
        xp,yp=StCoordLine(eigVec[i,2],eigVec[i,3],1,nargout=2)
# Bingham.m:191
        plot(xp,yp,'rs')
    
    #Plot best fit great circle
    path=GreatCircle(bestFit[1],bestFit[2],1)
# Bingham.m:196
    plot(path[:,1],path[:,2],'r')
    #release plot
    hold('off')
    return eigVec,confCone,bestFit
    
if __name__ == '__main__':
    pass
    